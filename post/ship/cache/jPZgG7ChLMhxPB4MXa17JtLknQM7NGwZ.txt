module.exports.config = {
    name: "callspadm",
    version: "1.0.0",
    hasPermssion: 0,
    credits: "DungUwU", //modded from sendnoti
    description: "G·ª≠i tin nh·∫Øn t·ªõi c√°c SUPER ADMIN ( ph·∫£n h·ªìi v√†o ·∫£nh/video c·∫ßn g·ª≠i k√®m )",
    commandCategory: "Box",
    usages: "< n·ªôi dung >",
    cooldowns: 30,
    dependencies: {
        "request": "",
        "fs": "",
        "moment-timezone": ""
    }
};

module.exports.languages = {
    "vi": {
        "sendSuccess": "[ ùóñùóîùóüùóüùóîùóó ] ‚Üí ƒê√£ g·ª≠i t√¢m th∆∞ t·ªõi %1 SUPER ADMIN",
        "sendFail": "[ ùóñùóîùóüùóüùóîùóó ] ‚Üí Kh√¥ng th·ªÉ g·ª≠i t√¢m th∆∞ t·ªõi %1 SUPER ADMIN"
    },
    "en": {
        "sendSuccess": "Sent message to %1 admin(s)!",
        "sendFail": "[!] Can't send message to %1 admin(s)"
    }
}

const requiredPath = __dirname + "/cache/";
module.exports.onLoad = async ({ }) => {
    const fs = global.nodemodule["fs"];
    if (!fs.existsSync(requiredPath)) fs.mkdirSync(requiredPath, { recursive: true });
}

module.exports.handleReply = async ({ api, event, Users, handleReply }) => {
    const ADMINIDs = global.config.SUPERADMIN;
    const { senderID, messageID, threadID, body } = event;

    const moment = global.nodemodule["moment-timezone"];

    let senderName = await Users.getNameUser(senderID),
        gio = moment.tz("Asia/Ho_Chi_Minh").format("DD/MM/YYYY || HH:mm:ss"),
        msg = {
            body: `====== ùóñùóîùóüùóüùóîùóó ======\n\n‚Üí Th·ªùi gian: ${gio}\n‚Üí Ph·∫£n h·ªìi t·ª´ th√†nh vi√™n: ${senderName}\n‚Üí URL Profile: https://www.facebook.com/profile.php?id=${senderID}\n‚Üí T√™n nh√≥m: ${global.data.threadInfo.get(threadID)?.threadName || "T√™n kh√¥ng t·ªìn t·∫°i"}\n‚Üí Ph·∫£n h·ªìi tin nh·∫Øn n√†y ƒë·ªÉ g·ª≠i ƒë·∫øn th√†nh vi√™n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Üí N·ªôi dung: ` + body
        }

    if (handleReply.from == 'user') {
        if (!ADMINIDs.includes(senderID)) return
        msg.body = `====== ùóñùóîùóüùóüùóîùóó ======\n\n‚Üí Th·ªùi gian: ${gio}\n‚Üí Ph·∫£n h·ªìi t·ª´ SUPER ADMIN: ${senderName}\n‚Üí URL Profile: https://www.facebook.com/profile.php?id=${senderID}\n‚Üí Ph·∫£n h·ªìi tin nh·∫Øn n√†y ƒë·ªÉ g·ª≠i ƒë·∫øn Ng∆∞·ªùi ƒëi·ªÅu h√†nh\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Üí N·ªôi dung: ` + body;
    }

    const callback = () => {
        api.sendMessage(msg, handleReply.threadID, (err, info) => {
            if (err) {
                console.log(err);
                api.setMessageReaction('‚ùå', messageID, null, true);
            }
            else {
                const handleReplyObject = {
                    name: this.config.name,
                    from: 'user',
                    messageID: info.messageID,
                    authorMessageID: messageID,
                    threadID: threadID,
                    author: senderID
                }

                if (handleReply.from == 'user') {
                    handleReplyObject.from = 'admin';
                }
                global.client.handleReply.push(handleReplyObject);
                api.setMessageReaction('‚úÖ', messageID, null, true);
            }
        }, handleReply.authorMessageID);
    }


    if (event.attachments[0]?.url) {
        const request = global.nodemodule["request"];
        const fs = global.nodemodule["fs"];

        let response = await request.get(event.attachments[0].url),
            pathname = response.uri.pathname,
            ext = pathname.substring(pathname.lastIndexOf(".") + 1),
            path = requiredPath + `cadmin_${Date.now()}.${ext}`;

        response
            .pipe(fs.createWriteStream(path))
            .on("close", () => {
                msg.attachment = fs.createReadStream(path);
                callback();
            })
    } else callback();
}

module.exports.run = async ({ api, event, args, getText, Users }) => {
    const { senderID, threadID, messageID } = event;
    const ADMINIDs = global.config.SUPERADMIN.filter(e => e != senderID);
    const moment = global.nodemodule["moment-timezone"];

    let count = 1,
        cantSend = [],
        userName = await Users.getNameUser(senderID),
        gio = moment.tz("Asia/Ho_Chi_Minh").format("DD/MM/YYYY || HH:mm:ss"),
        msg = {
            body: `====== ùóñùóîùóüùóüùóîùóó ======\n\n‚Üí Th·ªùi gian: ${gio}\n‚Üí Th√¥ng b√°o t·ª´ th√†nh vi√™n: ${userName}\n‚Üí URL Profile: https://www.facebook.com/profile.php?id=${senderID}\n‚Üí Ph·∫£n h·ªìi tin nh·∫Øn n√†y ƒë·ªÉ g·ª≠i ƒë·∫øn th√†nh vi√™n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n‚Üí N·ªôi dung: ` + args.join(` `),
        },
        hasAttach = false;


    const fs = global.nodemodule["fs"];
    let path;

    const callback = () => {
        let promises = []

        for (const adminID of ADMINIDs) {
            if (isNaN(parseInt(adminID)) || adminID == event.threadID) ""
            else {
                promises.push(new Promise(resolve => setTimeout(() => {
                    api.sendMessage(msg, adminID, (error, info) => {
                        if (error) cantSend.push(adminID);
                        else {
                            global.client.handleReply.push({
                                name: this.config.name,
                                from: 'user',
                                messageID: info.messageID,
                                authorMessageID: messageID,
                                threadID: threadID,
                                author: senderID
                            })
                            count++;
                        }
                        resolve();
                    });
                }, 500)))
            }
        }

        Promise.all(promises).then(() => {
            if (hasAttach) fs.unlinkSync(path);
            return api.sendMessage(getText("sendSuccess", count), event.threadID, () => (cantSend.length > 0) ? api.sendMessage(getText("sendFail", cantSend.length), event.threadID, event.messageID) : "", event.messageID);
        })
    }

    if (event.type == "message_reply" && event.messageReply.attachments[0]) {
        const request = global.nodemodule["request"];
        
        let response = await request.get(event.messageReply.attachments[0].url),
            pathname = response.uri.pathname,
            ext = pathname.substring(pathname.lastIndexOf(".") + 1);
          
            path = requiredPath + `cadmin_${Date.now()}.${ext}`;

        response
            .pipe(fs.createWriteStream(path))
            .on("close", () => {
                msg.attachment = fs.createReadStream(path);
                hasAttach = true;
                callback()
            })
    } else callback()
  }